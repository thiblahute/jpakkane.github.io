fragment_downloaded_cb({"url": "Simd-module.html#usage", "fragment": "Usage \nThis module is designed for the use case where you have an algorithm with one or more SIMD implementation and you choose which one to use at runtime. \nThe module provides one method check which is used like this \nHere the individual files contain the accelerated versions of the functions in question. The compiler keyword argument takes the compiler you are going to use to compile them. The function returns an array with two values. The first value is a bunch of libraries that contain the compiled code. Any SIMD code that the compiler can t compile for example Neon instructions on an x86 machine are ignored. You should pass this value to the desired target using link_with. The second value is a configuration_data object that contains true for all the values that were supported. For example if the compiler did support sse2 instructions then the object would have HAVE_SSE2 set to \nGenerating code to detect the proper instruction set at runtime is straightforward. First you create a header with the configuration object and then a chooser function that looks like this \nEach source file provides two functions the xxx_available function to query whether the CPU currently in use supports the instruction set and xxx_accelerated_function that is the corresponding accelerated implementation. \nAt the end of this function the function pointer points to the fastest available implementation and can be invoked to do the computation. \n"});